#include "pattern_collection_generator_rcg.h"
#include "pattern_database.h"
#include "rcg.h"
#include "utils.h"

#include "../option_parser.h"
#include "../plugin.h"
#include "../task_proxy.h"

#include "../task_utils/causal_graph.h"

#include "../utils/countdown_timer.h"
#include "../utils/logging.h"
#include "../utils/rng.h"
#include "../utils/rng_options.h"

#include <vector>

using namespace std;

namespace pdbs {
PatternCollectionGeneratorRCG::PatternCollectionGeneratorRCG(
    options::Options &opts)
    : max_pdb_size(opts.get<int>("max_pdb_size")),
      cegar_max_time(opts.get<double>("max_time")),
      verbosity(opts.get<utils::Verbosity>("verbosity")),
      rng(utils::parse_rng_from_options(opts)),
      stagnation_limit(opts.get<double>("stagnation_limit")),
      blacklist_trigger_percentage(opts.get<double>("blacklist_trigger_percentage")),
      enable_blacklist_on_stagnation(opts.get<bool>("enable_blacklist_on_stagnation")),
      total_max_time(opts.get<double>("total_max_time")),
      bidirectional(opts.get<bool>("bidirectional")),
      blacklisting(false),
      stagnation_start_time(-1),
      remaining_collection_size(opts.get<int>("max_collection_size")) {
}

void PatternCollectionGeneratorRCG::check_blacklist_trigger_timer(
    double blacklisting_start_time, const utils::CountdownTimer &timer) {
    // Check if blacklisting should be started.
    if (!blacklisting && timer.get_elapsed_time() > blacklisting_start_time) {
        blacklisting = true;
        // Also reset stagnation timer in case it was already set.
        stagnation_start_time = -1;
        if (verbosity >= utils::Verbosity::NORMAL) {
            utils::g_log << "given percentage of total time limit "
                         << "exhausted; enabling blacklisting." << endl;
        }
    }
}

unordered_set<int> PatternCollectionGeneratorRCG::get_blacklisted_variables(
    vector<int> &non_goal_variables) {
    unordered_set<int> blacklisted_variables;
    if (blacklisting && !non_goal_variables.empty()) {
        /*
          Randomize the number of non-goal variables for blacklisting.
          We want to choose at least 1 non-goal variable and up to the
          entire set of non-goal variables.
        */
        int blacklist_size = (*rng)(non_goal_variables.size());
        ++blacklist_size; // [1, |non-goal variables|]
        rng->shuffle(non_goal_variables);
        blacklisted_variables.insert(
            non_goal_variables.begin(), non_goal_variables.begin() + blacklist_size);
        if (verbosity >= utils::Verbosity::DEBUG) {
            utils::g_log << "blacklisting " << blacklist_size << " out of "
                         << non_goal_variables.size()
                         << " non-goal variables: ";
            for (int var : blacklisted_variables) {
                utils::g_log << var << ", ";
            }
            utils::g_log << endl;
        }
    }
    return blacklisted_variables;
}

void PatternCollectionGeneratorRCG::handle_generated_pattern(
    const TaskProxy &task_proxy,
    const Pattern &pattern,
    set<Pattern> &generated_patterns,
    const utils::CountdownTimer &timer) {
    if (verbosity >= utils::Verbosity::DEBUG) {
        utils::g_log << "generated patterns " << pattern << endl;
    }
    if (generated_patterns.insert(pattern).second) {
        // RCG generated a new pattern. Reset stagnation_start_time.
        stagnation_start_time = -1;
        int pdb_size = compute_pdb_size(task_proxy, pattern);
        remaining_collection_size -= pdb_size;
    } else {
        // Pattern is not new. Set stagnation start time if not already set.
        if (stagnation_start_time == -1) {
            stagnation_start_time = timer.get_elapsed_time();
        }
    }
}

bool PatternCollectionGeneratorRCG::collection_size_limit_reached() const {
    if (remaining_collection_size <= 0) {
        /*
          This value can become negative if the given size limits for
          pdb or collection size are so low that even the singleton
          goal pattern generated by RCG violates it.
        */
        if (verbosity >= utils::Verbosity::NORMAL) {
            utils::g_log << "collection size limit reached" << endl;
        }
        return true;
    }
    return false;
}

bool PatternCollectionGeneratorRCG::time_limit_reached(
    const utils::CountdownTimer &timer) const {
    if (timer.is_expired()) {
        if (verbosity >= utils::Verbosity::NORMAL) {
            utils::g_log << "time limit reached" << endl;
        }
        return true;
    }
    return false;
}

bool PatternCollectionGeneratorRCG::check_for_stagnation(
    const utils::CountdownTimer &timer) {
    // Test if no new pattern was generated for longer than stagnation_limit.
    if (stagnation_start_time != -1 &&
        timer.get_elapsed_time() - stagnation_start_time > stagnation_limit) {
        if (enable_blacklist_on_stagnation) {
            if (blacklisting) {
                if (verbosity >= utils::Verbosity::NORMAL) {
                    utils::g_log << "stagnation limit reached "
                                 << "despite blacklisting, terminating"
                                 << endl;
                }
                return true;
            } else {
                if (verbosity >= utils::Verbosity::NORMAL) {
                    utils::g_log << "stagnation limit reached, "
                                 << "enabling blacklisting" << endl;
                }
                blacklisting = true;
                stagnation_start_time = -1;
            }
        } else {
            if (verbosity >= utils::Verbosity::NORMAL) {
                utils::g_log << "stagnation limit reached, terminating" << endl;
            }
            return true;
        }
    }
    return false;
}

static PatternCollectionInformation get_pattern_collection(
    const TaskProxy &task_proxy, set<Pattern> &generated_patterns) {
    shared_ptr<PatternCollection> patterns = make_shared<PatternCollection>();
    patterns->insert(
        patterns->end(),
        make_move_iterator(generated_patterns.begin()),
        make_move_iterator(generated_patterns.end()));
    PatternCollectionInformation result(task_proxy, patterns);
    return result;
}

PatternCollectionInformation PatternCollectionGeneratorRCG::generate(
    const shared_ptr<AbstractTask> &task) {
    if (verbosity >= utils::Verbosity::NORMAL) {
        utils::g_log << "Generating patterns using the multiple RCG algorithm" << endl;
    }

    TaskProxy task_proxy(*task);
    utils::CountdownTimer timer(total_max_time);

    // Store the set of goals in random order.
    vector<FactPair> goals = get_goals_in_random_order(task_proxy, *rng);

    // Compute CG neighbors once. They will be shuffled after each use.
    vector<vector<int>> cg_neighbors = compute_cg_neighbors(
        task, bidirectional);

    // Store the non-goal variables for potential blacklisting.
    vector<int> non_goal_variables = get_non_goal_variables(task_proxy);

    if (verbosity >= utils::Verbosity::DEBUG) {
        utils::g_log << "goal variables: ";
        for (FactPair goal : goals) {
            utils::g_log << goal.var << ", ";
        }
        utils::g_log << endl;
        utils::g_log << "non-goal variables: " << non_goal_variables << endl;
    }

    // Collect all unique patterns.
    set<Pattern> generated_patterns;

    int num_iterations = 1;
    int goal_index = 0;
    const utils::Verbosity cegar_verbosity(utils::Verbosity::SILENT);
    /*
      Start blacklisting after the percentage of total_max_time specified via
      blacklisting_trigger_percentage has passed. Compute this time point once.
    */
    double blacklisting_start_time = total_max_time * blacklist_trigger_percentage;
    while (true) {
        check_blacklist_trigger_timer(blacklisting_start_time, timer);

        unordered_set<int> blacklisted_variables =
            get_blacklisted_variables(non_goal_variables);

        int remaining_pdb_size_for_cegar = min(remaining_collection_size, max_pdb_size);
        double remaining_time_for_cegar =
            min(static_cast<double>(timer.get_remaining_time()), cegar_max_time);
        Pattern pattern = generate_pattern_rcg(
            remaining_pdb_size_for_cegar,
            remaining_time_for_cegar,
            goals[goal_index].var,
            cegar_verbosity,
            rng,
            task_proxy,
            cg_neighbors
        );
        handle_generated_pattern(
            task_proxy,
            pattern,
            generated_patterns,
            timer);

        if (collection_size_limit_reached() ||
            time_limit_reached(timer) ||
            check_for_stagnation(timer)) {
            break;
        }

        ++num_iterations;
        ++goal_index;
        goal_index = goal_index % goals.size();
        assert(utils::in_bounds(goal_index, goals));
    }

    PatternCollectionInformation result =
        get_pattern_collection(task_proxy, generated_patterns);
    if (verbosity >= utils::Verbosity::NORMAL) {
        utils::g_log << "Multiple RCG number of iterations: "
                     << num_iterations << endl;
        utils::g_log << "Multiple RCG average time per generator: "
                     << timer.get_elapsed_time() / num_iterations
                     << endl;
        dump_pattern_collection_generation_statistics(
            "Multiple RCG",
            timer.get_elapsed_time(),
            result);
    }
    return result;
}

static shared_ptr<PatternCollectionGenerator> _parse(options::OptionParser &parser) {
    parser.add_option<int>(
        "max_collection_size",
        "maximum number of states in the pattern collection (ignored for the "
        "initial collection consisting of singleton patterns for each goal "
        "variable)",
        "20000000",
        Bounds("1", "infinity"));
    parser.add_option<double>(
        "total_max_time",
        "maximum time in seconds for the multiple RCG algorithm. The "
        "algorithm will always execute at least one iteration, i.e., call the "
        "RCG algorithm once. This limit possibly overrides the limit "
        "specified for the RCG algorithm.",
        "100.0",
        Bounds("0.0", "infinity"));
    parser.add_option<double>(
        "stagnation_limit",
        "maximum time in seconds the multiple RCG algorithm allows without "
        "generating a new pattern through the RCG algorithm. The multiple "
        "RCG algorithm terminates prematurely if this limit is hit unless "
        "enable_blacklist_on_stagnation is enabled.",
        "20.0",
        Bounds("1.0", "infinity"));
    parser.add_option<double>(
        "blacklist_trigger_percentage",
        "percentage of total_max_time after which the multiple RCG "
        "algorithm enables blacklisting for diversification",
        "0.75",
        Bounds("0.0", "1.0"));
    parser.add_option<bool>(
        "enable_blacklist_on_stagnation",
        "If true, the multiple RCG algorithm will enable blacklisting "
        "for diversification when stagnation_limit is hit for the first time "
        "(unless it was already enabled due to blacklist_trigger_percentage) "
        "and terminate when stagnation_limit is hit for the second time.",
        "true");
    add_rcg_options_to_parser(parser);
    utils::add_verbosity_option_to_parser(parser);
    utils::add_rng_options(parser);

    Options opts = parser.parse();
    if (parser.dry_run()) {
        return nullptr;
    }

    return make_shared<PatternCollectionGeneratorRCG>(opts);
}

static Plugin<PatternCollectionGenerator> _plugin("rcg_patterns", _parse);
}
